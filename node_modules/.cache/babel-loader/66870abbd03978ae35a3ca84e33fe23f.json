{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Action_1 = require(\"../core-actions/Action\");\n\nclass ZoomCanvasAction extends Action_1.Action {\n  constructor(options = {}) {\n    super({\n      type: Action_1.InputType.MOUSE_WHEEL,\n      fire: actionEvent => {\n        const {\n          event\n        } = actionEvent; // we can block layer rendering because we are only targeting the transforms\n\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(false);\n        }\n\n        const model = this.engine.getModel();\n        event.stopPropagation();\n        const oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n        let scrollDelta = options.inverseZoom ? -event.deltaY : event.deltaY; //check if it is pinch gesture\n\n        if (event.ctrlKey && scrollDelta % 1 !== 0) {\n          /*\n              Chrome and Firefox sends wheel event with deltaY that\n              have fractional part, also `ctrlKey` prop of the event is true\n              though ctrl isn't pressed\n          */\n          scrollDelta /= 3;\n        } else {\n          scrollDelta /= 60;\n        }\n\n        if (model.getZoomLevel() + scrollDelta > 10) {\n          model.setZoomLevel(model.getZoomLevel() + scrollDelta);\n        }\n\n        const zoomFactor = model.getZoomLevel() / 100;\n        const boundingRect = event.currentTarget.getBoundingClientRect();\n        const clientWidth = boundingRect.width;\n        const clientHeight = boundingRect.height; // compute difference between rect before and after scroll\n\n        const widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n        const heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor; // compute mouse coords relative to canvas\n\n        const clientX = event.clientX - boundingRect.left;\n        const clientY = event.clientY - boundingRect.top; // compute width and height increment factor\n\n        const xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n        const yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n        model.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n        this.engine.repaintCanvas(); // re-enable rendering\n\n        for (let layer of this.engine.getModel().getLayers()) {\n          layer.allowRepaint(true);\n        }\n      }\n    });\n  }\n\n}\n\nexports.ZoomCanvasAction = ZoomCanvasAction;","map":{"version":3,"sources":["../../../src/actions/ZoomCanvasAction.ts"],"names":[],"mappings":";;;;;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAMA,MAAa,gBAAb,SAAsC,QAAA,CAAA,MAAtC,CAA4C;AAC3C,EAAA,WAAA,CAAY,OAAA,GAAmC,EAA/C,EAAiD;AAChD,UAAM;AACL,MAAA,IAAI,EAAE,QAAA,CAAA,SAAA,CAAU,WADX;AAEL,MAAA,IAAI,EAAG,WAAD,IAAyC;AAC9C,cAAM;AAAE,UAAA;AAAF,YAAY,WAAlB,CAD8C,CAE9C;;AACA,aAAK,IAAI,KAAT,IAAkB,KAAK,MAAL,CAAY,QAAZ,GAAuB,SAAvB,EAAlB,EAAsD;AACrD,UAAA,KAAK,CAAC,YAAN,CAAmB,KAAnB;AACA;;AAED,cAAM,KAAK,GAAG,KAAK,MAAL,CAAY,QAAZ,EAAd;AACA,QAAA,KAAK,CAAC,eAAN;AACA,cAAM,aAAa,GAAG,KAAK,MAAL,CAAY,QAAZ,GAAuB,YAAvB,KAAwC,GAA9D;AACA,YAAI,WAAW,GAAG,OAAO,CAAC,WAAR,GAAsB,CAAC,KAAK,CAAC,MAA7B,GAAsC,KAAK,CAAC,MAA9D,CAV8C,CAW9C;;AACA,YAAI,KAAK,CAAC,OAAN,IAAiB,WAAW,GAAG,CAAd,KAAoB,CAAzC,EAA4C;AAC3C;;;;;AAKA,UAAA,WAAW,IAAI,CAAf;AACA,SAPD,MAOO;AACN,UAAA,WAAW,IAAI,EAAf;AACA;;AACD,YAAI,KAAK,CAAC,YAAN,KAAuB,WAAvB,GAAqC,EAAzC,EAA6C;AAC5C,UAAA,KAAK,CAAC,YAAN,CAAmB,KAAK,CAAC,YAAN,KAAuB,WAA1C;AACA;;AAED,cAAM,UAAU,GAAG,KAAK,CAAC,YAAN,KAAuB,GAA1C;AAEA,cAAM,YAAY,GAAG,KAAK,CAAC,aAAN,CAAoB,qBAApB,EAArB;AACA,cAAM,WAAW,GAAG,YAAY,CAAC,KAAjC;AACA,cAAM,YAAY,GAAG,YAAY,CAAC,MAAlC,CA9B8C,CA+B9C;;AACA,cAAM,SAAS,GAAG,WAAW,GAAG,UAAd,GAA2B,WAAW,GAAG,aAA3D;AACA,cAAM,UAAU,GAAG,YAAY,GAAG,UAAf,GAA4B,YAAY,GAAG,aAA9D,CAjC8C,CAkC9C;;AACA,cAAM,OAAO,GAAG,KAAK,CAAC,OAAN,GAAgB,YAAY,CAAC,IAA7C;AACA,cAAM,OAAO,GAAG,KAAK,CAAC,OAAN,GAAgB,YAAY,CAAC,GAA7C,CApC8C,CAsC9C;;AACA,cAAM,OAAO,GAAG,CAAC,OAAO,GAAG,KAAK,CAAC,UAAN,EAAX,IAAiC,aAAjC,GAAiD,WAAjE;AACA,cAAM,OAAO,GAAG,CAAC,OAAO,GAAG,KAAK,CAAC,UAAN,EAAX,IAAiC,aAAjC,GAAiD,YAAjE;AAEA,QAAA,KAAK,CAAC,SAAN,CAAgB,KAAK,CAAC,UAAN,KAAqB,SAAS,GAAG,OAAjD,EAA0D,KAAK,CAAC,UAAN,KAAqB,UAAU,GAAG,OAA5F;AACA,aAAK,MAAL,CAAY,aAAZ,GA3C8C,CA6C9C;;AACA,aAAK,IAAI,KAAT,IAAkB,KAAK,MAAL,CAAY,QAAZ,GAAuB,SAAvB,EAAlB,EAAsD;AACrD,UAAA,KAAK,CAAC,YAAN,CAAmB,IAAnB;AACA;AACD;AAnDI,KAAN;AAqDA;;AAvD0C;;AAA5C,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Action_1 = require(\"../core-actions/Action\");\nclass ZoomCanvasAction extends Action_1.Action {\n    constructor(options = {}) {\n        super({\n            type: Action_1.InputType.MOUSE_WHEEL,\n            fire: (actionEvent) => {\n                const { event } = actionEvent;\n                // we can block layer rendering because we are only targeting the transforms\n                for (let layer of this.engine.getModel().getLayers()) {\n                    layer.allowRepaint(false);\n                }\n                const model = this.engine.getModel();\n                event.stopPropagation();\n                const oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\n                let scrollDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\n                //check if it is pinch gesture\n                if (event.ctrlKey && scrollDelta % 1 !== 0) {\n                    /*\n                        Chrome and Firefox sends wheel event with deltaY that\n                        have fractional part, also `ctrlKey` prop of the event is true\n                        though ctrl isn't pressed\n                    */\n                    scrollDelta /= 3;\n                }\n                else {\n                    scrollDelta /= 60;\n                }\n                if (model.getZoomLevel() + scrollDelta > 10) {\n                    model.setZoomLevel(model.getZoomLevel() + scrollDelta);\n                }\n                const zoomFactor = model.getZoomLevel() / 100;\n                const boundingRect = event.currentTarget.getBoundingClientRect();\n                const clientWidth = boundingRect.width;\n                const clientHeight = boundingRect.height;\n                // compute difference between rect before and after scroll\n                const widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\n                const heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\n                // compute mouse coords relative to canvas\n                const clientX = event.clientX - boundingRect.left;\n                const clientY = event.clientY - boundingRect.top;\n                // compute width and height increment factor\n                const xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\n                const yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\n                model.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\n                this.engine.repaintCanvas();\n                // re-enable rendering\n                for (let layer of this.engine.getModel().getLayers()) {\n                    layer.allowRepaint(true);\n                }\n            }\n        });\n    }\n}\nexports.ZoomCanvasAction = ZoomCanvasAction;\n//# sourceMappingURL=ZoomCanvasAction.js.map"]},"metadata":{},"sourceType":"script"}