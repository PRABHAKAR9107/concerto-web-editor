{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst PF = require(\"pathfinding\");\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\n\n\nconst pathFinderInstance = new PF.JumpPointFinder({\n  heuristic: PF.Heuristic.manhattan,\n  diagonalMovement: PF.DiagonalMovement.Never\n});\n\nclass PathFinding {\n  constructor(factory) {\n    this.instance = pathFinderInstance;\n    this.factory = factory;\n  }\n  /**\n   * Taking as argument a fully unblocked walking matrix, this method\n   * finds a direct path from point A to B.\n   */\n\n\n  calculateDirectPath(from, to) {\n    const matrix = this.factory.getCanvasMatrix();\n    const grid = new PF.Grid(matrix);\n    return pathFinderInstance.findPath(this.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)), grid);\n  }\n  /**\n   * Using @link{#calculateDirectPath}'s result as input, we here\n   * determine the first walkable point found in the matrix that includes\n   * blocked paths.\n   */\n\n\n  calculateLinkStartEndCoords(matrix, path) {\n    const startIndex = path.findIndex(point => {\n      if (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;else return false;\n    });\n    const endIndex = path.length - 1 - path.slice().reverse().findIndex(point => {\n      if (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;else return false;\n    }); // are we trying to create a path exclusively through blocked areas?\n    // if so, let's fallback to the linear routing\n\n    if (startIndex === -1 || endIndex === -1) {\n      return undefined;\n    }\n\n    const pathToStart = path.slice(0, startIndex);\n    const pathToEnd = path.slice(endIndex);\n    return {\n      start: {\n        x: path[startIndex][0],\n        y: path[startIndex][1]\n      },\n      end: {\n        x: path[endIndex][0],\n        y: path[endIndex][1]\n      },\n      pathToStart,\n      pathToEnd\n    };\n  }\n  /**\n   * Puts everything together: merges the paths from/to the centre of the ports,\n   * with the path calculated around other elements.\n   */\n\n\n  calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd) {\n    // generate the path based on the matrix with obstacles\n    const grid = new PF.Grid(routingMatrix);\n    const dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid); // aggregate everything to have the calculated path ready for rendering\n\n    const pathCoords = pathToStart.concat(dynamicPath, pathToEnd).map(coords => [this.factory.translateRoutingX(coords[0], true), this.factory.translateRoutingY(coords[1], true)]);\n    return PF.Util.compressPath(pathCoords);\n  }\n\n}\n\nexports.default = PathFinding;","map":{"version":3,"sources":["../../../src/engine/PathFinding.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PF = require(\"pathfinding\");\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\nconst pathFinderInstance = new PF.JumpPointFinder({\n    heuristic: PF.Heuristic.manhattan,\n    diagonalMovement: PF.DiagonalMovement.Never\n});\nclass PathFinding {\n    constructor(factory) {\n        this.instance = pathFinderInstance;\n        this.factory = factory;\n    }\n    /**\n     * Taking as argument a fully unblocked walking matrix, this method\n     * finds a direct path from point A to B.\n     */\n    calculateDirectPath(from, to) {\n        const matrix = this.factory.getCanvasMatrix();\n        const grid = new PF.Grid(matrix);\n        return pathFinderInstance.findPath(this.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)), this.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)), grid);\n    }\n    /**\n     * Using @link{#calculateDirectPath}'s result as input, we here\n     * determine the first walkable point found in the matrix that includes\n     * blocked paths.\n     */\n    calculateLinkStartEndCoords(matrix, path) {\n        const startIndex = path.findIndex(point => {\n            if (matrix[point[1]])\n                return matrix[point[1]][point[0]] === 0;\n            else\n                return false;\n        });\n        const endIndex = path.length -\n            1 -\n            path\n                .slice()\n                .reverse()\n                .findIndex(point => {\n                if (matrix[point[1]])\n                    return matrix[point[1]][point[0]] === 0;\n                else\n                    return false;\n            });\n        // are we trying to create a path exclusively through blocked areas?\n        // if so, let's fallback to the linear routing\n        if (startIndex === -1 || endIndex === -1) {\n            return undefined;\n        }\n        const pathToStart = path.slice(0, startIndex);\n        const pathToEnd = path.slice(endIndex);\n        return {\n            start: {\n                x: path[startIndex][0],\n                y: path[startIndex][1]\n            },\n            end: {\n                x: path[endIndex][0],\n                y: path[endIndex][1]\n            },\n            pathToStart,\n            pathToEnd\n        };\n    }\n    /**\n     * Puts everything together: merges the paths from/to the centre of the ports,\n     * with the path calculated around other elements.\n     */\n    calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd) {\n        // generate the path based on the matrix with obstacles\n        const grid = new PF.Grid(routingMatrix);\n        const dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n        // aggregate everything to have the calculated path ready for rendering\n        const pathCoords = pathToStart\n            .concat(dynamicPath, pathToEnd)\n            .map(coords => [\n            this.factory.translateRoutingX(coords[0], true),\n            this.factory.translateRoutingY(coords[1], true)\n        ]);\n        return PF.Util.compressPath(pathCoords);\n    }\n}\nexports.default = PathFinding;\n//# sourceMappingURL=PathFinding.js.map"]},"metadata":{},"sourceType":"script"}