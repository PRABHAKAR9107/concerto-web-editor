{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst React = require(\"react\");\n\nconst styled_1 = require(\"@emotion/styled\");\n\nvar S;\n\n(function (S) {\n  S.Label = styled_1.default.div`\n\t\tdisplay: inline-block;\n\t\tposition: absolute;\n\t`;\n  S.Foreign = styled_1.default.foreignObject`\n\t\tpointer-events: none;\n\t\toverflow: visible;\n\t`;\n})(S || (S = {}));\n\nclass LabelWidget extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.findPathAndRelativePositionToRenderLabel = index => {\n      // an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\n      const link = this.props.label.getParent();\n      const lengths = link.getRenderedPath().map(path => path.getTotalLength()); // calculate the point where we want to display the label\n\n      let labelPosition = lengths.reduce((previousValue, currentValue) => previousValue + currentValue, 0) * (index / (link.getLabels().length + 1)); // find the path where the label will be rendered and calculate the relative position\n\n      let pathIndex = 0;\n\n      while (pathIndex < link.getRenderedPath().length) {\n        if (labelPosition - lengths[pathIndex] < 0) {\n          return {\n            path: link.getRenderedPath()[pathIndex],\n            position: labelPosition\n          };\n        } // keep searching\n\n\n        labelPosition -= lengths[pathIndex];\n        pathIndex++;\n      }\n    };\n\n    this.calculateLabelPosition = () => {\n      const found = this.findPathAndRelativePositionToRenderLabel(this.props.index + 1);\n\n      if (!found) {\n        return;\n      }\n\n      const {\n        path,\n        position\n      } = found;\n      const labelDimensions = {\n        width: this.ref.current.offsetWidth,\n        height: this.ref.current.offsetHeight\n      };\n      const pathCentre = path.getPointAtLength(position);\n      const labelCoordinates = {\n        x: pathCentre.x - labelDimensions.width / 2 + this.props.label.getOptions().offsetX,\n        y: pathCentre.y - labelDimensions.height / 2 + this.props.label.getOptions().offsetY\n      };\n      this.ref.current.style.transform = `translate(${labelCoordinates.x}px, ${labelCoordinates.y}px)`;\n    };\n\n    this.ref = React.createRef();\n  }\n\n  componentDidUpdate() {\n    window.requestAnimationFrame(this.calculateLabelPosition);\n  }\n\n  componentDidMount() {\n    window.requestAnimationFrame(this.calculateLabelPosition);\n  }\n\n  render() {\n    const canvas = this.props.engine.getCanvas();\n    return React.createElement(S.Foreign, {\n      key: this.props.label.getID(),\n      width: canvas.offsetWidth,\n      height: canvas.offsetHeight\n    }, React.createElement(S.Label, {\n      ref: this.ref\n    }, this.props.engine.getFactoryForLabel(this.props.label).generateReactWidget({\n      model: this.props.label\n    })));\n  }\n\n}\n\nexports.LabelWidget = LabelWidget;","map":{"version":3,"sources":["../../../../src/entities/label/LabelWidget.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = require(\"react\");\nconst styled_1 = require(\"@emotion/styled\");\nvar S;\n(function (S) {\n    S.Label = styled_1.default.div `\n\t\tdisplay: inline-block;\n\t\tposition: absolute;\n\t`;\n    S.Foreign = styled_1.default.foreignObject `\n\t\tpointer-events: none;\n\t\toverflow: visible;\n\t`;\n})(S || (S = {}));\nclass LabelWidget extends React.Component {\n    constructor(props) {\n        super(props);\n        this.findPathAndRelativePositionToRenderLabel = (index) => {\n            // an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\n            const link = this.props.label.getParent();\n            const lengths = link.getRenderedPath().map(path => path.getTotalLength());\n            // calculate the point where we want to display the label\n            let labelPosition = lengths.reduce((previousValue, currentValue) => previousValue + currentValue, 0) *\n                (index / (link.getLabels().length + 1));\n            // find the path where the label will be rendered and calculate the relative position\n            let pathIndex = 0;\n            while (pathIndex < link.getRenderedPath().length) {\n                if (labelPosition - lengths[pathIndex] < 0) {\n                    return {\n                        path: link.getRenderedPath()[pathIndex],\n                        position: labelPosition\n                    };\n                }\n                // keep searching\n                labelPosition -= lengths[pathIndex];\n                pathIndex++;\n            }\n        };\n        this.calculateLabelPosition = () => {\n            const found = this.findPathAndRelativePositionToRenderLabel(this.props.index + 1);\n            if (!found) {\n                return;\n            }\n            const { path, position } = found;\n            const labelDimensions = {\n                width: this.ref.current.offsetWidth,\n                height: this.ref.current.offsetHeight\n            };\n            const pathCentre = path.getPointAtLength(position);\n            const labelCoordinates = {\n                x: pathCentre.x - labelDimensions.width / 2 + this.props.label.getOptions().offsetX,\n                y: pathCentre.y - labelDimensions.height / 2 + this.props.label.getOptions().offsetY\n            };\n            this.ref.current.style.transform = `translate(${labelCoordinates.x}px, ${labelCoordinates.y}px)`;\n        };\n        this.ref = React.createRef();\n    }\n    componentDidUpdate() {\n        window.requestAnimationFrame(this.calculateLabelPosition);\n    }\n    componentDidMount() {\n        window.requestAnimationFrame(this.calculateLabelPosition);\n    }\n    render() {\n        const canvas = this.props.engine.getCanvas();\n        return (React.createElement(S.Foreign, { key: this.props.label.getID(), width: canvas.offsetWidth, height: canvas.offsetHeight },\n            React.createElement(S.Label, { ref: this.ref }, this.props.engine.getFactoryForLabel(this.props.label).generateReactWidget({ model: this.props.label }))));\n    }\n}\nexports.LabelWidget = LabelWidget;\n//# sourceMappingURL=LabelWidget.js.map"]},"metadata":{},"sourceType":"script"}