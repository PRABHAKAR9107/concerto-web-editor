{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst React = require(\"react\");\n\nconst PathFindingLinkModel_1 = require(\"./PathFindingLinkModel\");\n\nconst PathFindingLinkWidget_1 = require(\"./PathFindingLinkWidget\");\n\nconst _ = require(\"lodash\");\n\nconst Path = require(\"paths-js/path\");\n\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\n\nconst react_canvas_core_1 = require(\"@projectstorm/react-canvas-core\");\n\nclass PathFindingLinkFactory extends react_diagrams_defaults_1.DefaultLinkFactory {\n  constructor() {\n    super(PathFindingLinkFactory.NAME);\n    this.ROUTING_SCALING_FACTOR = 5; // calculated only when smart routing is active\n\n    this.canvasMatrix = [];\n    this.routingMatrix = []; // used when at least one element has negative coordinates\n\n    this.hAdjustmentFactor = 0;\n    this.vAdjustmentFactor = 0;\n    /**\n     * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n     * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n     */\n\n    this.calculateMatrixDimensions = () => {\n      const allNodesCoords = _.values(this.engine.getModel().getNodes()).map(item => ({\n        x: item.getX(),\n        width: item.width,\n        y: item.getY(),\n        height: item.height\n      }));\n\n      const allLinks = _.values(this.engine.getModel().getLinks());\n\n      const allPortsCoords = _.flatMap(allLinks.map(link => [link.getSourcePort(), link.getTargetPort()])).filter(port => port !== null).map(item => ({\n        x: item.getX(),\n        width: item.width,\n        y: item.getY(),\n        height: item.height\n      }));\n\n      const allPointsCoords = _.flatMap(allLinks.map(link => link.getPoints())).map(item => ({\n        // points don't have width/height, so let's just use 0\n        x: item.getX(),\n        width: 0,\n        y: item.getY(),\n        height: 0\n      }));\n\n      const sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n\n      const canvas = this.engine.getCanvas();\n\n      const concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n\n      const minX = Math.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\n      const maxXElement = _.maxBy(concatedCoords, item => sumProps(item, ['x', 'width']));\n\n      const maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n\n      const minYCoords = _.minBy(concatedCoords, 'y');\n\n      const minY = Math.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\n      const maxYElement = _.maxBy(concatedCoords, item => sumProps(item, ['y', 'height']));\n\n      const maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n      return {\n        width: Math.ceil(Math.abs(minX) + maxX),\n        hAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n        height: Math.ceil(Math.abs(minY) + maxY),\n        vAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n      };\n    };\n    /**\n     * Updates (by reference) where nodes will be drawn on the matrix passed in.\n     */\n\n\n    this.markNodes = matrix => {\n      _.values(this.engine.getModel().getNodes()).forEach(node => {\n        const startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n        const endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n        const startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n        const endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n\n        for (let x = startX - 1; x <= endX + 1; x++) {\n          for (let y = startY - 1; y < endY + 1; y++) {\n            this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n          }\n        }\n      });\n    };\n    /**\n     * Updates (by reference) where ports will be drawn on the matrix passed in.\n     */\n\n\n    this.markPorts = matrix => {\n      const allElements = _.flatMap(_.values(this.engine.getModel().getLinks()).map(link => [].concat(link.getSourcePort(), link.getTargetPort())));\n\n      allElements.filter(port => port !== null).forEach(port => {\n        const startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n        const endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n        const startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n        const endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n\n        for (let x = startX - 1; x <= endX + 1; x++) {\n          for (let y = startY - 1; y < endY + 1; y++) {\n            this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n          }\n        }\n      });\n    };\n\n    this.markMatrixPoint = (matrix, x, y) => {\n      if (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n        matrix[y][x] = 1;\n      }\n    };\n  }\n\n  setDiagramEngine(engine) {\n    super.setDiagramEngine(engine); // listen for drag changes\n\n    engine.getStateMachine().registerListener({\n      stateChanged: event => {\n        if (event.newState instanceof react_canvas_core_1.AbstractDisplacementState) {\n          const deRegister = engine.getActionEventBus().registerAction(new react_canvas_core_1.Action({\n            type: react_canvas_core_1.InputType.MOUSE_UP,\n            fire: () => {\n              this.calculateRoutingMatrix();\n              engine.repaintCanvas();\n              deRegister();\n            }\n          }));\n        }\n      }\n    });\n    this.listener = engine.registerListener({\n      canvasReady: () => {\n        _.defer(() => {\n          this.calculateRoutingMatrix();\n          engine.repaintCanvas();\n        });\n      }\n    });\n  }\n\n  setFactoryBank(bank) {\n    super.setFactoryBank(bank);\n\n    if (!bank && this.listener) {\n      this.listener.deregister();\n    }\n  }\n\n  generateReactWidget(event) {\n    return React.createElement(PathFindingLinkWidget_1.PathFindingLinkWidget, {\n      diagramEngine: this.engine,\n      link: event.model,\n      factory: this\n    });\n  }\n\n  generateModel(event) {\n    return new PathFindingLinkModel_1.PathFindingLinkModel();\n  }\n  /**\n   * A representation of the canvas in the following format:\n   *\n   * +-----------------+\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * | 0 0 0 0 0 0 0 0 |\n   * +-----------------+\n   *\n   * In which all walkable points are marked by zeros.\n   * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n   */\n\n\n  getCanvasMatrix() {\n    if (this.canvasMatrix.length === 0) {\n      this.calculateCanvasMatrix();\n    }\n\n    return this.canvasMatrix;\n  }\n\n  calculateCanvasMatrix() {\n    const {\n      width: canvasWidth,\n      hAdjustmentFactor,\n      height: canvasHeight,\n      vAdjustmentFactor\n    } = this.calculateMatrixDimensions();\n    this.hAdjustmentFactor = hAdjustmentFactor;\n    this.vAdjustmentFactor = vAdjustmentFactor;\n    const matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n    const matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n    this.canvasMatrix = _.range(0, matrixHeight).map(() => {\n      return new Array(matrixWidth).fill(0);\n    });\n  }\n  /**\n   * A representation of the canvas in the following format:\n   *\n   * +-----------------+\n   * | 0 0 1 1 0 0 0 0 |\n   * | 0 0 1 1 0 0 1 1 |\n   * | 0 0 0 0 0 0 1 1 |\n   * | 1 1 0 0 0 0 0 0 |\n   * | 1 1 0 0 0 0 0 0 |\n   * +-----------------+\n   *\n   * In which all points blocked by a node (and its ports) are\n   * marked as 1; points were there is nothing (ie, free) receive 0.\n   */\n\n\n  getRoutingMatrix() {\n    if (this.routingMatrix.length === 0) {\n      this.calculateRoutingMatrix();\n    }\n\n    return this.routingMatrix;\n  }\n\n  calculateRoutingMatrix() {\n    const matrix = _.cloneDeep(this.getCanvasMatrix()); // nodes need to be marked as blocked points\n\n\n    this.markNodes(matrix); // same thing for ports\n\n    this.markPorts(matrix);\n    this.routingMatrix = matrix;\n  }\n  /**\n   * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n   * We use the functions below to translate back and forth between these coordinates, relying on the\n   * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n   */\n\n\n  translateRoutingX(x, reverse = false) {\n    return x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n  }\n\n  translateRoutingY(y, reverse = false) {\n    return y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n  }\n\n  generateDynamicPath(pathCoords) {\n    let path = Path();\n    path = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n    pathCoords.slice(1).forEach(coords => {\n      path = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n    });\n    return path.print();\n  }\n\n}\n\nPathFindingLinkFactory.NAME = 'pathfinding';\nexports.PathFindingLinkFactory = PathFindingLinkFactory;","map":{"version":3,"sources":["../../../src/link/PathFindingLinkFactory.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = require(\"react\");\nconst PathFindingLinkModel_1 = require(\"./PathFindingLinkModel\");\nconst PathFindingLinkWidget_1 = require(\"./PathFindingLinkWidget\");\nconst _ = require(\"lodash\");\nconst Path = require(\"paths-js/path\");\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\nconst react_canvas_core_1 = require(\"@projectstorm/react-canvas-core\");\nclass PathFindingLinkFactory extends react_diagrams_defaults_1.DefaultLinkFactory {\n    constructor() {\n        super(PathFindingLinkFactory.NAME);\n        this.ROUTING_SCALING_FACTOR = 5;\n        // calculated only when smart routing is active\n        this.canvasMatrix = [];\n        this.routingMatrix = [];\n        // used when at least one element has negative coordinates\n        this.hAdjustmentFactor = 0;\n        this.vAdjustmentFactor = 0;\n        /**\n         * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n         * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n         */\n        this.calculateMatrixDimensions = () => {\n            const allNodesCoords = _.values(this.engine.getModel().getNodes()).map(item => ({\n                x: item.getX(),\n                width: item.width,\n                y: item.getY(),\n                height: item.height\n            }));\n            const allLinks = _.values(this.engine.getModel().getLinks());\n            const allPortsCoords = _.flatMap(allLinks.map(link => [link.getSourcePort(), link.getTargetPort()]))\n                .filter(port => port !== null)\n                .map(item => ({\n                x: item.getX(),\n                width: item.width,\n                y: item.getY(),\n                height: item.height\n            }));\n            const allPointsCoords = _.flatMap(allLinks.map(link => link.getPoints())).map(item => ({\n                // points don't have width/height, so let's just use 0\n                x: item.getX(),\n                width: 0,\n                y: item.getY(),\n                height: 0\n            }));\n            const sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n            const canvas = this.engine.getCanvas();\n            const concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n            const minX = Math.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) *\n                this.ROUTING_SCALING_FACTOR;\n            const maxXElement = _.maxBy(concatedCoords, item => sumProps(item, ['x', 'width']));\n            const maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n            const minYCoords = _.minBy(concatedCoords, 'y');\n            const minY = Math.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n            const maxYElement = _.maxBy(concatedCoords, item => sumProps(item, ['y', 'height']));\n            const maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n            return {\n                width: Math.ceil(Math.abs(minX) + maxX),\n                hAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n                height: Math.ceil(Math.abs(minY) + maxY),\n                vAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n            };\n        };\n        /**\n         * Updates (by reference) where nodes will be drawn on the matrix passed in.\n         */\n        this.markNodes = (matrix) => {\n            _.values(this.engine.getModel().getNodes()).forEach(node => {\n                const startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n                const endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n                const startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n                const endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n                for (let x = startX - 1; x <= endX + 1; x++) {\n                    for (let y = startY - 1; y < endY + 1; y++) {\n                        this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n                    }\n                }\n            });\n        };\n        /**\n         * Updates (by reference) where ports will be drawn on the matrix passed in.\n         */\n        this.markPorts = (matrix) => {\n            const allElements = _.flatMap(_.values(this.engine.getModel().getLinks()).map(link => [].concat(link.getSourcePort(), link.getTargetPort())));\n            allElements\n                .filter(port => port !== null)\n                .forEach(port => {\n                const startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n                const endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n                const startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n                const endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n                for (let x = startX - 1; x <= endX + 1; x++) {\n                    for (let y = startY - 1; y < endY + 1; y++) {\n                        this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n                    }\n                }\n            });\n        };\n        this.markMatrixPoint = (matrix, x, y) => {\n            if (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n                matrix[y][x] = 1;\n            }\n        };\n    }\n    setDiagramEngine(engine) {\n        super.setDiagramEngine(engine);\n        // listen for drag changes\n        engine.getStateMachine().registerListener({\n            stateChanged: event => {\n                if (event.newState instanceof react_canvas_core_1.AbstractDisplacementState) {\n                    const deRegister = engine.getActionEventBus().registerAction(new react_canvas_core_1.Action({\n                        type: react_canvas_core_1.InputType.MOUSE_UP,\n                        fire: () => {\n                            this.calculateRoutingMatrix();\n                            engine.repaintCanvas();\n                            deRegister();\n                        }\n                    }));\n                }\n            }\n        });\n        this.listener = engine.registerListener({\n            canvasReady: () => {\n                _.defer(() => {\n                    this.calculateRoutingMatrix();\n                    engine.repaintCanvas();\n                });\n            }\n        });\n    }\n    setFactoryBank(bank) {\n        super.setFactoryBank(bank);\n        if (!bank && this.listener) {\n            this.listener.deregister();\n        }\n    }\n    generateReactWidget(event) {\n        return React.createElement(PathFindingLinkWidget_1.PathFindingLinkWidget, { diagramEngine: this.engine, link: event.model, factory: this });\n    }\n    generateModel(event) {\n        return new PathFindingLinkModel_1.PathFindingLinkModel();\n    }\n    /**\n     * A representation of the canvas in the following format:\n     *\n     * +-----------------+\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * +-----------------+\n     *\n     * In which all walkable points are marked by zeros.\n     * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n     */\n    getCanvasMatrix() {\n        if (this.canvasMatrix.length === 0) {\n            this.calculateCanvasMatrix();\n        }\n        return this.canvasMatrix;\n    }\n    calculateCanvasMatrix() {\n        const { width: canvasWidth, hAdjustmentFactor, height: canvasHeight, vAdjustmentFactor } = this.calculateMatrixDimensions();\n        this.hAdjustmentFactor = hAdjustmentFactor;\n        this.vAdjustmentFactor = vAdjustmentFactor;\n        const matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n        const matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n        this.canvasMatrix = _.range(0, matrixHeight).map(() => {\n            return new Array(matrixWidth).fill(0);\n        });\n    }\n    /**\n     * A representation of the canvas in the following format:\n     *\n     * +-----------------+\n     * | 0 0 1 1 0 0 0 0 |\n     * | 0 0 1 1 0 0 1 1 |\n     * | 0 0 0 0 0 0 1 1 |\n     * | 1 1 0 0 0 0 0 0 |\n     * | 1 1 0 0 0 0 0 0 |\n     * +-----------------+\n     *\n     * In which all points blocked by a node (and its ports) are\n     * marked as 1; points were there is nothing (ie, free) receive 0.\n     */\n    getRoutingMatrix() {\n        if (this.routingMatrix.length === 0) {\n            this.calculateRoutingMatrix();\n        }\n        return this.routingMatrix;\n    }\n    calculateRoutingMatrix() {\n        const matrix = _.cloneDeep(this.getCanvasMatrix());\n        // nodes need to be marked as blocked points\n        this.markNodes(matrix);\n        // same thing for ports\n        this.markPorts(matrix);\n        this.routingMatrix = matrix;\n    }\n    /**\n     * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n     * We use the functions below to translate back and forth between these coordinates, relying on the\n     * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n     */\n    translateRoutingX(x, reverse = false) {\n        return x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n    }\n    translateRoutingY(y, reverse = false) {\n        return y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n    }\n    generateDynamicPath(pathCoords) {\n        let path = Path();\n        path = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n        pathCoords.slice(1).forEach(coords => {\n            path = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n        });\n        return path.print();\n    }\n}\nPathFindingLinkFactory.NAME = 'pathfinding';\nexports.PathFindingLinkFactory = PathFindingLinkFactory;\n//# sourceMappingURL=PathFindingLinkFactory.js.map"]},"metadata":{},"sourceType":"script"}