{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Action_1 = require(\"../core-actions/Action\");\n\nconst _ = require(\"lodash\");\n\nclass State {\n  constructor(options) {\n    this.actions = [];\n    this.keys = [];\n    this.childStates = [];\n    this.options = options;\n  }\n\n  setEngine(engine) {\n    this.engine = engine;\n  }\n\n  getOptions() {\n    return this.options;\n  }\n\n  eject() {\n    this.engine.getStateMachine().popState();\n  }\n\n  transitionWithEvent(state, event) {\n    this.engine.getStateMachine().pushState(state);\n    this.engine.getActionEventBus().fireAction(event);\n  }\n\n  registerAction(action) {\n    this.actions.push(action);\n  }\n\n  tryActivateParentState(keys) {\n    if (this.keys.length > 0 && !this.isKeysFullfilled(keys)) {\n      this.eject();\n      return true;\n    }\n\n    return false;\n  }\n\n  tryActivateChildState(keys) {\n    const state = this.findStateToActivate(keys);\n\n    if (state) {\n      this.engine.getStateMachine().pushState(state);\n      return true;\n    }\n\n    return false;\n  }\n\n  findStateToActivate(keys) {\n    for (let child of this.childStates) {\n      if (child.isKeysFullfilled(keys)) {\n        return child;\n      }\n    }\n\n    return null;\n  }\n\n  isKeysFullfilled(keys) {\n    return _.intersection(this.keys, keys).length === this.keys.length;\n  }\n\n  activated(previous) {\n    const keys = this.engine.getActionEventBus().getKeys();\n\n    if (this.tryActivateParentState(keys) || this.tryActivateChildState(keys)) {\n      return;\n    } // perhaps we need to pop again?\n\n\n    this.handler1 = this.engine.getActionEventBus().registerAction(new Action_1.Action({\n      type: Action_1.InputType.KEY_DOWN,\n      fire: () => {\n        this.tryActivateChildState(this.engine.getActionEventBus().getKeys());\n      }\n    }));\n    this.handler2 = this.engine.getActionEventBus().registerAction(new Action_1.Action({\n      type: Action_1.InputType.KEY_UP,\n      fire: () => {\n        this.tryActivateParentState(this.engine.getActionEventBus().getKeys());\n      }\n    }));\n\n    for (let action of this.actions) {\n      this.engine.getActionEventBus().registerAction(action);\n    }\n  }\n\n  deactivated(next) {\n    if (this.handler1) {\n      this.handler1();\n    }\n\n    if (this.handler2) {\n      this.handler2();\n    } // if this happens, we are going into heirachial state machine mode\n\n\n    for (let action of this.actions) {\n      this.engine.getActionEventBus().deregisterAction(action);\n    }\n  }\n\n}\n\nexports.State = State;","map":{"version":3,"sources":["../../../src/core-state/State.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Action_1 = require(\"../core-actions/Action\");\nconst _ = require(\"lodash\");\nclass State {\n    constructor(options) {\n        this.actions = [];\n        this.keys = [];\n        this.childStates = [];\n        this.options = options;\n    }\n    setEngine(engine) {\n        this.engine = engine;\n    }\n    getOptions() {\n        return this.options;\n    }\n    eject() {\n        this.engine.getStateMachine().popState();\n    }\n    transitionWithEvent(state, event) {\n        this.engine.getStateMachine().pushState(state);\n        this.engine.getActionEventBus().fireAction(event);\n    }\n    registerAction(action) {\n        this.actions.push(action);\n    }\n    tryActivateParentState(keys) {\n        if (this.keys.length > 0 && !this.isKeysFullfilled(keys)) {\n            this.eject();\n            return true;\n        }\n        return false;\n    }\n    tryActivateChildState(keys) {\n        const state = this.findStateToActivate(keys);\n        if (state) {\n            this.engine.getStateMachine().pushState(state);\n            return true;\n        }\n        return false;\n    }\n    findStateToActivate(keys) {\n        for (let child of this.childStates) {\n            if (child.isKeysFullfilled(keys)) {\n                return child;\n            }\n        }\n        return null;\n    }\n    isKeysFullfilled(keys) {\n        return _.intersection(this.keys, keys).length === this.keys.length;\n    }\n    activated(previous) {\n        const keys = this.engine.getActionEventBus().getKeys();\n        if (this.tryActivateParentState(keys) || this.tryActivateChildState(keys)) {\n            return;\n        }\n        // perhaps we need to pop again?\n        this.handler1 = this.engine.getActionEventBus().registerAction(new Action_1.Action({\n            type: Action_1.InputType.KEY_DOWN,\n            fire: () => {\n                this.tryActivateChildState(this.engine.getActionEventBus().getKeys());\n            }\n        }));\n        this.handler2 = this.engine.getActionEventBus().registerAction(new Action_1.Action({\n            type: Action_1.InputType.KEY_UP,\n            fire: () => {\n                this.tryActivateParentState(this.engine.getActionEventBus().getKeys());\n            }\n        }));\n        for (let action of this.actions) {\n            this.engine.getActionEventBus().registerAction(action);\n        }\n    }\n    deactivated(next) {\n        if (this.handler1) {\n            this.handler1();\n        }\n        if (this.handler2) {\n            this.handler2();\n        }\n        // if this happens, we are going into heirachial state machine mode\n        for (let action of this.actions) {\n            this.engine.getActionEventBus().deregisterAction(action);\n        }\n    }\n}\nexports.State = State;\n//# sourceMappingURL=State.js.map"]},"metadata":{},"sourceType":"script"}