{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Point_1 = require(\"./Point\");\n\nconst _ = require(\"lodash\");\n\nclass Polygon {\n  constructor(points = []) {\n    this.points = points;\n  }\n\n  serialize() {\n    return _.map(this.points, point => {\n      return [point.x, point.y];\n    });\n  }\n\n  deserialize(data) {\n    this.points = _.map(data, point => {\n      return new Point_1.Point(point[0], point[1]);\n    });\n  }\n\n  scale(x, y, origin) {\n    let matrix = Point_1.Point.createScaleMatrix(x, y, origin);\n\n    _.forEach(this.points, point => {\n      point.transform(matrix);\n    });\n  }\n\n  transform(matrix) {\n    _.forEach(this.points, point => {\n      point.transform(matrix);\n    });\n  }\n\n  setPoints(points) {\n    this.points = points;\n  }\n\n  getPoints() {\n    return this.points;\n  }\n\n  rotate(degrees) {\n    this.transform(Point_1.Point.createRotateMatrix(degrees / (180 / Math.PI), this.getOrigin()));\n  }\n\n  translate(offsetX, offsetY) {\n    _.forEach(this.points, point => {\n      point.translate(offsetX, offsetY);\n    });\n  }\n\n  doClone(ob) {\n    this.points = _.map(ob.points, point => {\n      return point.clone();\n    });\n  }\n\n  clone() {\n    let ob = Object.create(this);\n    ob.doClone(this);\n    return ob;\n  }\n\n  getOrigin() {\n    if (this.points.length === 0) {\n      return null;\n    }\n\n    let dimensions = this.getBoundingBox();\n    return Point_1.Point.middlePoint(dimensions.getTopLeft(), dimensions.getBottomRight());\n  }\n\n  static boundingBoxFromPolygons(polygons) {\n    return Polygon.boundingBoxFromPoints(_.flatMap(polygons, polygon => {\n      return polygon.getPoints();\n    }));\n  }\n\n  static boundingBoxFromPoints(points) {\n    if (points.length === 0) {\n      return new Rectangle_1.Rectangle(0, 0, 0, 0);\n    }\n\n    let minX = points[0].x;\n    let maxX = points[0].x;\n    let minY = points[0].y;\n    let maxY = points[0].y;\n\n    for (let i = 1; i < points.length; i++) {\n      if (points[i].x < minX) {\n        minX = points[i].x;\n      }\n\n      if (points[i].x > maxX) {\n        maxX = points[i].x;\n      }\n\n      if (points[i].y < minY) {\n        minY = points[i].y;\n      }\n\n      if (points[i].y > maxY) {\n        maxY = points[i].y;\n      }\n    }\n\n    return new Rectangle_1.Rectangle(new Point_1.Point(minX, minY), new Point_1.Point(maxX, minY), new Point_1.Point(maxX, maxY), new Point_1.Point(minX, maxY));\n  }\n\n  getBoundingBox() {\n    let minX = this.points[0].x;\n    let maxX = this.points[0].x;\n    let minY = this.points[0].y;\n    let maxY = this.points[0].y;\n\n    for (let i = 1; i < this.points.length; i++) {\n      if (this.points[i].x < minX) {\n        minX = this.points[i].x;\n      }\n\n      if (this.points[i].x > maxX) {\n        maxX = this.points[i].x;\n      }\n\n      if (this.points[i].y < minY) {\n        minY = this.points[i].y;\n      }\n\n      if (this.points[i].y > maxY) {\n        maxY = this.points[i].y;\n      }\n    }\n\n    return new Rectangle_1.Rectangle(new Point_1.Point(minX, minY), new Point_1.Point(maxX, minY), new Point_1.Point(maxX, maxY), new Point_1.Point(minX, maxY));\n  }\n\n}\n\nexports.Polygon = Polygon;\n\nconst Rectangle_1 = require(\"./Rectangle\");","map":{"version":3,"sources":["../../src/Polygon.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Point_1 = require(\"./Point\");\nconst _ = require(\"lodash\");\nclass Polygon {\n    constructor(points = []) {\n        this.points = points;\n    }\n    serialize() {\n        return _.map(this.points, point => {\n            return [point.x, point.y];\n        });\n    }\n    deserialize(data) {\n        this.points = _.map(data, point => {\n            return new Point_1.Point(point[0], point[1]);\n        });\n    }\n    scale(x, y, origin) {\n        let matrix = Point_1.Point.createScaleMatrix(x, y, origin);\n        _.forEach(this.points, point => {\n            point.transform(matrix);\n        });\n    }\n    transform(matrix) {\n        _.forEach(this.points, point => {\n            point.transform(matrix);\n        });\n    }\n    setPoints(points) {\n        this.points = points;\n    }\n    getPoints() {\n        return this.points;\n    }\n    rotate(degrees) {\n        this.transform(Point_1.Point.createRotateMatrix(degrees / (180 / Math.PI), this.getOrigin()));\n    }\n    translate(offsetX, offsetY) {\n        _.forEach(this.points, point => {\n            point.translate(offsetX, offsetY);\n        });\n    }\n    doClone(ob) {\n        this.points = _.map(ob.points, point => {\n            return point.clone();\n        });\n    }\n    clone() {\n        let ob = Object.create(this);\n        ob.doClone(this);\n        return ob;\n    }\n    getOrigin() {\n        if (this.points.length === 0) {\n            return null;\n        }\n        let dimensions = this.getBoundingBox();\n        return Point_1.Point.middlePoint(dimensions.getTopLeft(), dimensions.getBottomRight());\n    }\n    static boundingBoxFromPolygons(polygons) {\n        return Polygon.boundingBoxFromPoints(_.flatMap(polygons, polygon => {\n            return polygon.getPoints();\n        }));\n    }\n    static boundingBoxFromPoints(points) {\n        if (points.length === 0) {\n            return new Rectangle_1.Rectangle(0, 0, 0, 0);\n        }\n        let minX = points[0].x;\n        let maxX = points[0].x;\n        let minY = points[0].y;\n        let maxY = points[0].y;\n        for (let i = 1; i < points.length; i++) {\n            if (points[i].x < minX) {\n                minX = points[i].x;\n            }\n            if (points[i].x > maxX) {\n                maxX = points[i].x;\n            }\n            if (points[i].y < minY) {\n                minY = points[i].y;\n            }\n            if (points[i].y > maxY) {\n                maxY = points[i].y;\n            }\n        }\n        return new Rectangle_1.Rectangle(new Point_1.Point(minX, minY), new Point_1.Point(maxX, minY), new Point_1.Point(maxX, maxY), new Point_1.Point(minX, maxY));\n    }\n    getBoundingBox() {\n        let minX = this.points[0].x;\n        let maxX = this.points[0].x;\n        let minY = this.points[0].y;\n        let maxY = this.points[0].y;\n        for (let i = 1; i < this.points.length; i++) {\n            if (this.points[i].x < minX) {\n                minX = this.points[i].x;\n            }\n            if (this.points[i].x > maxX) {\n                maxX = this.points[i].x;\n            }\n            if (this.points[i].y < minY) {\n                minY = this.points[i].y;\n            }\n            if (this.points[i].y > maxY) {\n                maxY = this.points[i].y;\n            }\n        }\n        return new Rectangle_1.Rectangle(new Point_1.Point(minX, minY), new Point_1.Point(maxX, minY), new Point_1.Point(maxX, maxY), new Point_1.Point(minX, maxY));\n    }\n}\nexports.Polygon = Polygon;\nconst Rectangle_1 = require(\"./Rectangle\");\n//# sourceMappingURL=Polygon.js.map"]},"metadata":{},"sourceType":"script"}