"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var nodePath = _interopDefault(require("path")), sourceMap = require("source-map"), convert = _interopDefault(require("convert-source-map")), findRoot = _interopDefault(require("find-root")), memoize = _interopDefault(require("@emotion/memoize")), hashString = _interopDefault(require("@emotion/hash")), escapeRegexp = _interopDefault(require("escape-string-regexp")), serialize = require("@emotion/serialize"), helperModuleImports = require("@babel/helper-module-imports"), babelPluginMacros = require("babel-plugin-macros"), multilineCommentRegex = /\/\*[^!](.|[\r\n])*?\*\//g, lineCommentStart = /\/\//g, symbolRegex = /(\s*[;:{},]\s*)/g, countOccurences = function(str, substr) {
  return str.split(substr).length - 1;
}, reduceSubstr = function(substrs, join, predicate) {
  var length = substrs.length, res = substrs[0];
  if (1 === length) return res;
  for (var i = 1; i < length && !predicate(res); i++) res += join + substrs[i];
  return res;
}, stripLineComment = function(line) {
  return reduceSubstr(line.split(lineCommentStart), "//", function(str) {
    return !str.endsWith(":") && countOccurences(str, "'") % 2 == 0 && countOccurences(str, '"') % 2 == 0 && countOccurences(str, "(") === countOccurences(str, ")");
  });
}, compressSymbols = function(code) {
  return code.split(symbolRegex).reduce(function(str, fragment, index) {
    return index % 2 == 0 ? str + fragment : countOccurences(str, "'") % 2 == 0 && countOccurences(str, '"') % 2 == 0 ? str + fragment.trim() : str + fragment;
  }, "");
}, isLineComment = function(line) {
  return line.trim().startsWith("//");
}, linebreakRegex = /[\r\n]\s*/g, spacesAndLinebreakRegex = /\s+|\n+/g;

function multilineReplacer(match) {
  return match.indexOf("@") > -1 ? match.replace(spacesAndLinebreakRegex, " ").trim() : "\n";
}

var minify = function(code) {
  var newCode = code.replace(multilineCommentRegex, multilineReplacer).split(linebreakRegex).filter(function(line) {
    return line.length > 0 && !isLineComment(line);
  }).map(stripLineComment).join(" ");
  return compressSymbols(newCode);
};

function getExpressionsFromTemplateLiteral(node, t) {
  var raw = createRawStringFromTemplateLiteral(node);
  return replacePlaceholdersWithExpressions(minify(raw), node.expressions || [], t);
}

var interleave = function(strings, interpolations) {
  return interpolations.reduce(function(array, interp, i) {
    return array.concat([ interp ], strings[i + 1]);
  }, [ strings[0] ]);
};

function getDynamicMatches(str) {
  for (var match, re = /xxx(\d+)xxx/gm, matches = []; null !== (match = re.exec(str)); ) null !== match && matches.push({
    value: match[0],
    p1: parseInt(match[1], 10),
    index: match.index
  });
  return matches;
}

function replacePlaceholdersWithExpressions(str, expressions, t) {
  var matches = getDynamicMatches(str);
  if (0 === matches.length) return "" === str ? [] : [ t.stringLiteral(str) ];
  var strings = [], finalExpressions = [], cursor = 0;
  return matches.forEach(function(_ref, i) {
    var value = _ref.value, p1 = _ref.p1, index = _ref.index, preMatch = str.substring(cursor, index);
    cursor = cursor + preMatch.length + value.length, preMatch ? strings.push(t.stringLiteral(preMatch)) : 0 === i && strings.push(t.stringLiteral("")), 
    finalExpressions.push(expressions[p1]), i === matches.length - 1 && strings.push(t.stringLiteral(str.substring(index + value.length)));
  }), interleave(strings, finalExpressions).filter(function(node) {
    return "" !== node.value;
  });
}

function createRawStringFromTemplateLiteral(quasi) {
  var strs = quasi.quasis.map(function(x) {
    return x.value.cooked;
  });
  return strs.reduce(function(arr, str, i) {
    return arr.push(str), i !== strs.length - 1 && arr.push("xxx" + i + "xxx"), arr;
  }, []).join("").trim();
}

var invalidClassNameCharacters = /[!"#$%&'()*+,.\/:;<=>?@[\]^`|}~{]/g, sanitizeLabelPart = function(labelPart) {
  return labelPart.trim().replace(invalidClassNameCharacters, "-");
};

function getLabel(identifierName, autoLabel, labelFormat, filename) {
  if (!identifierName || !autoLabel) return null;
  if (!labelFormat) return sanitizeLabelPart(identifierName);
  var parsedPath = nodePath.parse